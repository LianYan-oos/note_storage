# 																																																MySQL 优化

## MySql 概述

​	数据库是 数据存储的仓库，数据有组织的进行存储   简称: DataBase（DB）

​	数据库管理系统： 操纵和管理数据库的大型软件  简称: DataBase Management System（DBMS）

​	比如: Mysql , Origin，SqlServer 都是数据库管理系统

​	通过SQL 进行操作数据库 

​	SQL ： 操作关系型数据库的编程语言，定义了一套操作关系型数据库的同意标准 Structured Query Language （SQL）

​	$\textcolor{red}{关系型数据库}$: 建立在关系模型的基础上，有多张相互链接的二维表组成的数据库

​	特点：

1. 使用表存储数据，格式统一，便于维护
2. 使用SQL 语言操作，标准统一，使用方便

   $\textcolor{red}{二维表}$：就是像Excel 表格

##  $\textcolor{red}{MySql数据模型}$

![image-20230305121510226](./assets/image-20230305121510226.png)

## $\textcolor{red}{SQL}$

### 	SQL通用语法:

1. 语句可以单行或者多行书写，以分号结尾
2. SQL语句可以使用空格/缩进来增强语句的可读性
3. MySQL数据库的SQL语句不区分大小写，关键字建议使用大写
4. 注释:
    - 单行注释：--注释内容 或者 #注释内容
    - 多行注释：/* 注释内容 */

### 	SQL分类：

1. DDL：Data Definition Language 数据定义语言，用来定义数据库对象（数据库，表，字段）
2. DML：Data Manipulation Language 数据操作语言,用来对数据库表中的数据进行增删改
3. DQL：Data Query Language 数据库查询语言，用来查询数据库表中的记录
4. DCL：Data Control Language 数据控制语言，用来创建数据库用户，控制数据库的访问权限

### 	DDL：

- 查询

    - 查询所有数据库

        ```sql
        SHOW DATABASES ;
        ```

    - 查询当前数据库

        ```sql
        SELECT DATABASE();
        ```

    - 创建

        ```sql
        CREATE DATABASE IF NOT EXISTS 数据库名称 DEFAULT CHAR SET 字符集 COLLATE 排序规则;
        字符集 utf8mb4 占用四个字节 默认是三个字节
        ```

    - 删除

        ```sql
        DROP DATABASE IF EXISTS 数据库名称;
        ```

    - 使用

        ```sql
        USE 数据库名称;
        ```

    - 查询当前数据库所有表

        ```sql
        SHOW TABLES;
        ```

    - 查询表结构

        ```sql
        DESC 表名称;
        ```

    - 查询指定表的创建语句

        ```sql
        SHOW CREATE TABLE 表名称;
        ```

    - 表操作-创建

        ```sql
        CREATE TABLE 表名称(
            字段 类型 COMMENT'字段注释'
        ) COMMENT '表注释';
        ```


### 		数值类型

| 分类     | 类型         | 大小    | 有符号（SIGNED）范围                                    | 无符号(UNSIGNED)范围                                       | 描述                 |
| :------- | :----------- | :------ | :------------------------------------------------------ | :--------------------------------------------------------- | :------------------- |
| 数值类型 | TINYINT      | 1 byte  | (-128,127)                                              | （0-255）                                                  | 小整数值             |
| 数值类型 | SMALLINT     | 2 byte  | (-32768,32767)                                          | （0-65535）                                                | 大整数值             |
| 数值类型 | MEDIUMINT    | 3 byte  | (-8388608,8388607)                                      | （0-16777215）                                             | 大整数值             |
| 数值类型 | INT或INTEGER | 4 byte  | (-2147483648,2147483647)                                | （0-4294967295）                                           | 大整数值             |
| 数值类型 | BIGINT       | 8 byte  | (-2^63, 2^63-1)                                         | （0-2^64-1）                                               | 极大整数值           |
| 数值类型 | FLOAT        | 4 byte  | (-3.402823466E+38,3.402823466351E+38)                   | 0 和 （1.75494351 E-38, 3.402823466 E+38）                 | 单精度浮点数值       |
| 数值类型 | DOUBLE       | 8  byte | (-1.7976931348623157E+308,1.7976931348623157E+308)jeitu | 0 和（2.2250738585072014 E-308, 1.7976931348623157 E+308） | 双精度浮点数值       |
| 数值类型 | DECIMAL      |         | 依赖于M（精度）和D（标度）的值                          | 依赖于M（精度）和D（标度）的值                             | 小数值（精确定点数） |

### 		字符串类型

| 分类       | 类型       | 大小               | 描述                         |
| ---------- | ---------- | ------------------ | ---------------------------- |
|            | CHAR       | 0-255 bytes        | 定长字符串 性能高            |     | VARCHAR    | 0-65535 bytes      | 变长字符串 性能差            |
|            | TINYBLOB   | 0-255 bytes        | 不超过255个字符的二进制数据  |
|            | TINYTEXT   | 0-255 bytes        | 短文本字符串                 |
|            | BLOB       | 0-65 535 bytes     | 二进制形式的长文本数据       |
| 字符串类型 | TEXT       | 0-65 535 bytes     | 长文本数据                   |
|            | MEDIUMBLOB | 0-16777215 bytes   | 二进制形式的中等长度文本数据 |
|            | MEDIUMTEXT | 0-16777215 bytes   | 中等长度文本数据             |
|            | LONGBLOB   | 0-4294967295 bytes | 二进制形式的极大文本数据     |
|            | LONGTEXT   | 0-4294967295 bytes | 极大文本数据                 |

### 		时间类型

​	

| 分类     | 类型      | 大小 | 范围                                       | 格式                 | 描述                     |
| -------- | --------- | ---- | ------------------------------------------ | -------------------- | ------------------------ |
|          | DATE      | 3    | 1000-01-01 至 9999-12-31                   | YYYY-MM-DD           | 日期值                   |
|          | TIME      | 3    | -838:59:59 至 838:59:59                    | HH:MM:SS             | 时间值或持续时间         |
| 日期类型 | YEAR      | 1    | 1901 至 2155                               | YYYY                 | 年份值                   |
|          | DATETIME  | 8    | 1000-01-01 00:00:00 至 9999-12-31 23:59:59 | YYYY-MM-DD  HH:MM:SS | 混合日期和时间值         |
|          | TIMESTAMP | 4    | 1970-01-01 00:00:01 至 2038-01-19 03:14:07 | YYYY-MM-DD  HH:MM:SS | 混合日期和时间值，时间戳 |

- 表操作-修改

    - 添加字段

        ```sql
        ALTER TABLE 表名 ADD 字段名称 类型(长度) COMMENT'注释' 约束;
        ```

    - 修改数据类型

        ```sql
        ALTER TABLE 表名 MODIFY 字段名 新数据类型(长度)
        ```

    - 修改字段名和字段类型

        ```sql
        ALTER TABLE 表名 CHANGE 旧表名 新表名 类型(长度) COMMENT '注释' 约束
        ```

    - 删除字段

        ```sql
        ALTER TABLE 表名 DROP 字段名 ;
        ```

    - 修改表名

        ```sql
        ALTER TABLE 表名 RENAME TO 新表名;
        ```

### DML：

- 添加单行数据

    ```sql
    INSERT INTO 表名 VALUES (字段1值，字段2值);
    
    INSERT INTO 表名(字段1,字段2) VALUES (字段1值，字段2值);
    ```

- 添加多行数据

    ```sql
    INSERT INTO 表名(字段1,字段2) VALUES (字段1值，字段2值),(字段1值，字段2值);
    ```

- 修改数据

    ```sql
     UPDATE 表名 SET 字段=修改值 WHERE 修改条件
    ```

- 删除数据

    ```sql
    DELETE FROM 表名 WHERE 修改条件
    ```

### DQL：

- 关键字 为 SELECT

    ```sql
    SELECT
        字段列表
    FROM
        表名
    WHERE
        条件列表
    GROUP BY
        分组列表
    HAVING
        分组后列表条件
    ORDER BY
        排序列表
    LIMIT
        分页列表
    ```

- 查询多个字段

    ```sql
    SELECT 字段1,字段2,字段3....FROM 表明;
    
    SELECT * FROM 表明;
    ```

- 设置别名

    ```sql
    SELECT 字段1[AS 别名1],字段2[AS 别名2]... FROM 表明;
    ```

- 去除重复记录

    ```sql
    SELECT DISTINCT 字段列表 FROM 表明;
    ```

#### **DQL-条件查询**

- 语法：

    ```sql
    SELECT 字段列表 FROM WHERE 条件列表;
    ```

- 条件

    | 比较运算符        | 功能                                   | 逻辑运算符 | 功能                     |
    | ----------------- | -------------------------------------- | ---------- | ------------------------ |
    | \>                | 大于                                   | AND 或 &&  | 并且（多个条件同事成立） |
    | \>=               | 大于等于                               | OR 或 \|\| | 或者（多个条件任意成立） |
    | <                 | 小于                                   | NOT 或  !  | 非，不是                 |
    | <=                | 小于等于                               |            |                          |
    | =                 | 等于                                   |            |                          |
    | <> 或 !=          | 不等于                                 |            |                          |
    | BETWEEN...AND.... | 在某个范围之内(含最小,最大值)          |            |                          |
    | IN(....)          | 在in之后的列表中的值，多选一           |            |                          |
    | LIKE 占位符       | 模糊匹配(_匹配单个字符，%匹配任意字符) |            |                          |
    | IS NULL           | 是NULL                                 |            |                          |

#### DQL-聚合函数

- 介绍

    - 将一列数据作为以一个整体，进行纵向计算

- 常见的聚合函数

    | 函数  | 功能     |
    | ----- | -------- |
    | count | 统计数量 |
    | max   | 最大值   |
    | min   | 最小值   |
    | avg   | 平均值   |
    | sum   | 求和     |

- 语法

    ```sql
    SELECT 聚合函数(字段列表) FROM 表名;
    
    注意: null值不参与所有聚合函数的运算
    ```

#### DQL-分组查询

- 语法

    ```sql
    SELECT 字段列表 FROM 表名 WHERE 条件 GROUP BY 分组字段名 HAVING 分组后的过滤条件;
    ```

- WHERE 和	HAVING 的区别

    - 执行时机不同：where 是分组之前进行过滤，不满足where的条件，不参与分组；而having是分组之后对结果进行过滤的
    - 判断条件不同：where不能对聚合函数进行判断，而having可以 
    - 注意
        - 执行顺序：where >聚合函数 >having
        - 分组之后：查询的字段一般为聚合函数和分组字段，查询其他字段无任何意义

#### DQL-排序查询

- 语法

    ```sql
    SELECT 字段列表 FROM 表名 ORDER BY 字段1 排序方式1，字段2 排序方式2;
    ```

- 排序方式

    - ASC：升序（默认）

    - DESC：降序

        $\textcolor{red}{注意：如果是多个字段排序，当第一个字段值相同时，才会根据第二个字段进行排序}$

#### DQL-分页查询

- 语法

    ```sql
    SELECT 字段列表 FROM 表名 LIMIT 起始索引,查询记录数;
    ```

- 注意

    - 起始索引从0开始，起始索引=（查询页码-1）*每页显示的记录数
    - 分页查询是数据库的方言，不同数据库有不同的实现，Mysql中是LIMIT
    - 如果查询的是第一页数据，起始索引可以省略，直接简写为LIMIT 10

#### DQL-执行顺序：

![image-20230305121545761](./assets/image-20230305121545761.png)

### DCL-介绍：

- DCL：Data Control Language 数据控制语言，用来创建数据库用户，控制数据库的访问权限

#### DCL-管理用户

- 查询用户

    ```sql
    USE mysql
    SELECT * FROM user;
    ```

- 创建用户

    ```sql
    CREATE USER '用户名'@'主机名' IDENTIFIED BY '密码';
    ```

- 修改用户密码

    ```sql
    ALTER USER '用户名'@'主机名' IDENTIFIED WITH mysql_native_password BY '新密码';
    ```

- 删除用户

    ```sql
    DROP USER '用户名'@'主机名';
    ```

- 注意

    - 主机名可以使用 % 通配
    - 这类SQL开发人员操作的比较少，主要是DBA（Database Administrator 数据管理员）使用

#### DCL-权限控制

- MySQL中定义了许多种权限，但常用的就是以下几种：

    | 权限               | 说明             |
    | :----------------- | :--------------- |
    | ALL,ALL PRIVILEGES | 所有权限         |
    | SELECT             | 查询数据         |
    | INSERT             | 播入数据         |
    | UPDATE             | 修改数据         |
    | DELETE             | 刪除数据         |
    | ALTER              | 修改表           |
    | DROP               | 除数据库/表/视图 |
    | CREATE             | 创建数据库/表    |

- 查询权限

    ```sql
    SHOW GRANTS FOR '用户名'@'主机';
    ```

- 授予权限

    ```sql
    GRANT 权限列表 ON 数据库名称.表名 TO '用户名'@‘'主机名';
    ```

- 撤销权限

    ```sql
    REVOKE 权限列表 ON 数据库名称.表名 FROM '用户名'@'主机名';
    ```

### 函数：

​	函数：是指一段可以直接被另一段程序调用的程序或代码。

1. 字符串函数
2. 数值函数
3. 日期函数
4. 流程函数

#### 字符串函数：

​	MySQL中内置了很多的字符串函数,常用的几个如下：

| 函数                     | 功能                                                      |
| ------------------------ | --------------------------------------------------------- |
| CONCAT(S1,S2,...Sn)      | 字符串拼接，将51,52，.Sn拼接成一个字符串                  |
| LOWER(str)               | 将字符串str全部转为小写                                   |
| UPPER(str)               | 将字符串str全部转为大写                                   |
| LPAD(str,n,pad)          | 左填充，用字符串pad对str的左边进行填充，达到n个字符串长度 |
| RPAD(str,n,pad)          | 右填充，用字符串pad对st的右边进行填充，达到n个字符串长度  |
| TRIM(str)                | 去掉字符串头部和尾部的空格                                |
| SUBSTRING(str,start,len) | 返回从字符串str从sart位置起的len个长度的字符串            |

​	语法

```sql
SELECT 函数(参数);
```

#### 数值函数：

​	常见的数值函数如下：

| 函数       | 函数                              |
| ---------- | --------------------------------- |
| CEIL(x)    | 向上取整                          |
| FLOOR(X)   | 向下取整                          |
| MOD(x,y)   | 返回x/y的模                       |
| RAND()     | 返回01内的随机数                  |
| ROUND(x,y) | 求参数的四舍五入的值，保留y位小数 |

#### 日期函数：

​	常见的日期函数如下：

| 函数                              | 功能                                             |
| --------------------------------- | ------------------------------------------------ |
| CURDATE()                         | 返回当前日期                                     |
| CURTIME()                         | 返回当前时间                                     |
| NOW()                             | 返回当前日期和时间                               |
| YEAR(date)                        | 获取指定date的年份                               |
| MONTH(date)                       | 获取指定date的月份                               |
| DAY(date)                         | 获取指定date的日期                               |
| DATE_ADD(date,INTERVAL expr type) | 返回一个日期/时间值加上一个时间间隔xpr后的时间值 |
| DAILDIFF(date1,dale2)             | 返回起始时间dle1和结束时间dale2之间的天数        |

#### 流程函数：

​	流程函数也是一类函数，可以在SQL语句中实现条件筛选，从而提高语句的效率

| 函数                                                  | 功能                                               |
| ----------------------------------------------------- | -------------------------------------------------- |
| IF(value,t,f)                                         | 如果alue为tue,则返回t,否则返回f                    |
| IFNULL(valuel value2)                                 | 如果value1不为空，返回value1,否则返回alue2         |
| CASE WHEN [val1 J THEN [res1]..ELSE default END       | 如果valT为true,返回es1,.否则返回detaut默认值       |
| CASE expr」WHEN [val1」THEN [res1]..ELSE default」END | 如果epr的值等于all,返回resl,.否则返回default默认值 |

### 约束

​	概述：约束是作用于表中字段上的规则，用于限制存储在表中的数据。

​	目的：保证数据库中数据的正确，有效性和完整性。

​	分类：

| 约束                    | 描述                                                     | 关键字      |
| ----------------------- | -------------------------------------------------------- | ----------- |
| 非空约束                | 限制该字段的数据不能为null                               | NOT NULL    |
| 唯一约束                | 保证该字段的所有数据鄂是唯一、不重复的                   | UNIQUE      |
| 主键约束                | 主键是一行数据的难一标识，要求非空且唯一                 | PRIMARY KEY |
| 默认约束                | 保存数据时，如果未指定该字段的值，则采用默认值           | DFFAULT     |
| 检查约束8.0.16版本之后) | 保证字段值满足某一个条件                                 | CHECK       |
| 外键约束                | 用来让两张表的数据之间建立连接，保证数据的一致性和完整性 | FORFIGN KFY |

$\textcolor{red}{注意：约束时作用与表中字段上的，可以在创建表/修改表的时候添加约束}$

语法：

```sql
CREATE TABLE 表名(
    字段 类型 约束 COMMENT'注释'
)COMMENT '注释';
```

#### 外键约束：

​	概念：外键用来让两张表的数据之间建立链接，从而保证数据的一致性和完整性

![image-20230305201019076](./assets/image-20230305201019076.png)

#### 语法：

##### 		添加外键

```sql
#创建表的时候
CREATE TABLE tb_user(
    字段名 数据类型,
    CONSTRAINT 外键名称 FOREIGN KEY (外键字段名) REFERENCES 主表(主表列名)
) COMMENT '注释';


修改表结构
ALTER TABLE 表名 ADD CONSTRAINT 外键名称 FOREIGN KEY (外键字段名) REFERENCES 主表(主表列名);
```

##### 		删除外键

```sql
ALTER TABLE 表名 DROP FOREIGN KEY 外键名称;
```

##### 		删除/更新行为

| 行为        | 说明                                                         |
| ----------- | ------------------------------------------------------------ |
| NO ACTION   | 当在父表中删除/更新对应记录时，首先检查该记录是否有对应外键，如果有则不允许删除/更新。（与RESTRICT一致） |
| RESTRICT    | 当在父表中删除/更新对应记录时，首先检查该记录是否有对应外键，如果有则不允许删除/更新。（与NO ACTION一致） |
| CASCADE     | 当在父表中删除/更新对应记录时，首先检查该记录是否有对应外键，如果有，则也删除更新外键在子表中的记录。 |
| SET NULL    | 当在父表中删除对应记录时，首先检查该记录是否有对应外键，如果有则设置子表中该外键值为null(这就要求该外键允许取ull) |
| SET DEFAULT | 父表有变更时，子表将外键列设置成一个默认的值(Innodb不支持)   |

```sql
ALTER TABLE 表名 ADD CONSTRAINT 外键名称 FOREIGN KEY (外键字段名) REFERENCES 主表(主表列名) ON UPDATE CASCADE ON DELETE CASCADE;


# SET NULL 的约束
ALTER TABLE 表名 ADD CONSTRAINT 外键名称 FOREIGN KEY (外键字段名) REFERENCES 主表(主表列名) ON UPDATE SET NULL ON DELETE SET NULL ;
```

### 多表查询

#### 	多表关系

​		概述：

项目开发中，在进行数据库表结构设计时，会根据业务需求及业务模块之间的关系，分析并设计表结构，由于业务之间相互关联，所以各个表结构之间也存在着各种联系，基本上分为三种：

1. 一对多（多对一）

    1. 案例：部门与员工的关系
    2. 关系：一个部门对应多个员工，一个员工对应一个部门
    3. 实现：在多的一方建立外键，指向一的一方的主键

    ![image-20230305201817951](./assets/image-20230305201817951.png)

2. 多对多

    1. 案例：学生与课程的关系

    2. 关系：一个学生可以选修多门课程，一门课程也可以提供多个学生选择

    3. 实现：建立第三张中间表，中间表至少包含两个外键，分别关联两方的主键

        ![image-20230305201928057](./assets/image-20230305201928057.png)

3. 一对一

    1. 案例：用户与用户详情的关系

    2. 关系：一对一关系，多用于单表拆分，将一张表的基础字段放在一张表中，其他详情字段放在另一张表中，以提升操作效率

    3. 实现：在任意一方加入外键，关联另一方的主键，并且设置外键为唯一的（UNIQUE）

        ![image-20230305202006223](./assets/image-20230305202006223.png)

#### 多表查询

​	概述：指从多张表中查询数据

​	笛卡尔积：笛卡尔积是指在数学中，两个集合A集合和B集合的所有组合情况（在多表查询时，需要消除无效的笛卡尔积）

![image-20230305202108129](./assets/image-20230305202108129.png)

#### 多表查询分类

1. 连接查询

    1. 内连接：相当于查询A，B交集部分数据
    2. 外连接
        1. 左外连接：查询左表所有数据，以及两张表交集部分数据
        2. 右外连接：查询右表所有数据，以及两张表交集部分数据
    3. 自连接：当前表与自身的连接查询，自连接不许使用表别名

2. 子查询

    1. 连接查询-内连接

        1. 内连接查询语法

            1. 隐式查询

                ```sql
                SELECT 字段列表 FROM 表1,表2 WHERE 连接条件（表的主外键）;
                ```

            2. 显示查询

                ```sql
                SELECT 字段列表 FROM 表1 别名 INNER JOIN 表2 别名 ON 连接条件（表的主外键）;
                
                可以省略 INNER
                ```

        2. $\textcolor{red}{内连接查询的是两张表交集的部分}$

            ![image-20230305202527498](./assets/image-20230305202527498.png)

    2. 连接查询-外连接

        1. 连接查询语法

            1. 左外连接

                ```sql
                SELECT 字段列表 FROM 表1 别名 LEFT JOIN 表2 别名 ON 连接条件（表的主外键）;
                
                SELECT 字段列表 FROM 表1 别名 LEFT OUTER JOIN 表2 别名 ON 连接条件（表的主外键）;
                可以省略 OUTER
                ```

                $\textcolor{red}{相当于查询表1（左表）的所有数据 包含 表1和表2交集的部分的数据}$

            2. 右连接

                ```sql
                SELECT 字段列表 FROM 表1 别名 RIGHT JOIN 表2 别名 ON 连接条件（表的主外键）;
                
                SELECT 字段列表 FROM 表1 别名 RIGHT OUTER JOIN 表2 别名 ON 连接条件（表的主外键）;
                可以省略 OUTER
                ```

                $\textcolor{red}{相当于查询表2（右表）的所有数据 包含 表1和表2交集的部分的数据}$

    3. 连接查询-自连接

        1. 自连接查询语法：

            ```sql
            SELECT 字段列表 FROM 表A 别名 JOIN 表A 别名 ON 连接条件;
            SELECT 字段列表 FROM 表A 别名 , 表A 别名 WHERE 连接条件;
            
            -- 外连接
            SELECT 字段列表 FROM 表A 别名 LEFT JOIN 表A 别名 ON 连接条件;
            SELECT 字段列表 FROM 表A 别名 RIGHT JOIN 表A 别名 ON 连接条件;
            ```

            $\textcolor{red}{自连接查询，可以是内连接查询，也可以是外连接查询}$

    4. 联合查询-union，union all

        1. 概述：对于union查询，就是把多次查询的结果合并起来，形成一个新的查询结果集。

        2. 语法

            ```sql
            SELECT 字段列表 FROM 表A
            UNION
            SELECT 字段列表 FROM 表B;
            -- 给查询的结果合并之后去重
            -- 或者
            SELECT 字段列表 FROM 表A
            UNION ALL
            SELECT 字段列表 FROM 表B;
            --直接查询全部结果
            ```

            $\textcolor{red}{对于联合查询的多张表的列数必须保持一直，字段类型也需要保持一致}$

            $\textcolor{red}{UNION ALL 会将全部的数据直接合并在一起，UNION会对合并之后的数据去重}$

3. 子查询

    1. 概述：SQL语句中嵌套SELECT语句，称为嵌套查询，又称子查询

        ```sql
        SELECT * FROM 表1 WHERE 列名 = (SELECT 列名 FROM 表2)
        ```

        $\textcolor{red}{子查询外部的语句可以是INSERT / UPDATE / DELECT / SELECT 的任何一个}$

    2. 根据子查询的结果不同，分为：

        - 标量子查询（子查询结果值为单个值）
        - 列子查询（子查询的结果为一列）
        - 行子查询（子查询的结果为一行）
        - 表子查询（子查询的结果为多列）

    3. 根据子查询位置，分为：WHERE之后，FROM之后，SELECT之后

    4. 子查询

        1. 标量子查询

            1. 概述：子查询返回的结果是单个值（数字，字符串，日期等），最简单的形式，这种子查询称为标量子查询

            2. 常用的操作符：=  	<>		>	>=	<		<=

            3. 语法：

                ```sql
                SELECT * FROM 表1 WHERE 列名 = (SELECT 列名 FROM 表2 WHERE 条件);
                SELECT * FROM 表1 WHERE 列名 <> (SELECT 列名 FROM 表2 WHERE 条件);
                SELECT * FROM 表1 WHERE 列名 > (SELECT 列名 FROM 表2 WHERE 条件);
                SELECT * FROM 表1 WHERE 列名 >= (SELECT 列名 FROM 表2 WHERE 条件);
                SELECT * FROM 表1 WHERE 列名 < (SELECT 列名 FROM 表2 WHERE 条件);
                SELECT * FROM 表1 WHERE 列名 <= (SELECT 列名 FROM 表2 WHERE 条件);
                ```

        2. 列子查询

            1. 概述：子查询返回的结果是一列（可以是多行），这种子查询称为列子查询

            2. 常用的操作符：IN		NOT IN		ANY			SOME		ALL	

                | 操作符 | 描述                                   |
                | ------ | -------------------------------------- |
                | IN     | 在指定的集合范围之内，多选一           |
                | NOT IN | 不在指定的集合范围之内                 |
                | ANY    | 子查询返回列表中，有任意一个满足即可   |
                | SOME   | 与ANY等同，使用SOME的地方都可以使用ANY |
                | ALL    | 子查询返回列表的所有值都必须满足       |

            3. 语法：

                ```sql
                SELECT * FROM 表1 WHERE 列名 IN (SELECT 列名 FROM 表2 WHERE 条件1);
                
                SELECT * FROM 表1 WHERE 列名 > ALL (SELECT 列名 FROM 表2 WHERE 条件1);
                
                SELECT * FROM 表1 WHERE 列名 > ANY (SELECT 列名 FROM 表2 WHERE 条件1);
                
                SELECT * FROM 表1 WHERE 列名 > SOME (SELECT 列名 FROM 表2 WHERE 条件1);
                ```

        3. 行子查询：

            1. 概述：子查询的返回结果返回的结果是一行（可以是多列），这种子查询称为行字查询

            2. 常用的操作符：=	<>	IN	NOT	IN

                ```sql
                SELECT 列名 FROM 表名 WHERE (条件1,条件2) = (SELECT 条件1列名,条件2列名 FROM 表名 WHERE 删选条件)
                ```

        4. 表字查询：

            1. 概述：子查询返回的结果是多行多列，这种子查询称为表子查询

            2. 常用的操作符：IN

                ```
                SELECT 列名 FROM 表名 WHERE(条件1,条件2) IN (SELECT 条件1列名,条件2列名 FROM 表名 WHERE 筛选条件)
                
                SELECT 列名 FROM (SELECT 列名 FROM 表名 WHERE 筛选条件) 别名 LEFT JOIN 连接条件
                ```

### 事务：

​	事务是一组操作的集合，他是一个不可分割的工作单位，事务会把所有的操作作为一个整体一起向系统提交或撤销操作请求，即这些操作要么同时成功，要么同时失败

![image-20230305204928100](./assets/image-20230305204928100.png)

​	默认MySQL的事务是自动提交的，也就是说，当执行一条DML语句，MySQL会立即隐式提交事务

#### 	事务操作：

1. 查看/设置事务提交方式

    ```sql
    SELECT @@autocommit;
    
    SET @@autocommit=0;
    ```

2. 提交事务

    ```sql
    COMMIT;
    ```

3. 回滚事务

    ```sql
    ROLLBACK;
    ```

4. 开启事务

    ```sql
    SELECT TSTART TRANSACTION 或者 BEGIN
    ```

#### 事务的四大特性：

​	原子性(Atomicity)：事务是不可分割的最小操作单元，要么全部成功，要么全部失败。

​	一致性(Consistency)：事务完成时，必须使所有的数据都保持一致状态。

​	隔离性(Isolation)：数据库系统提供的隔离机制，保证事务在不受外部并发操作影响的独立环境下运行。

​	持久性(Durability)：事务一旦提交或回滚，它对数据库中的数据的改变就是永久的。

#### 并发事务问题：

| 问题       | 描述                                                         |
| ---------- | ------------------------------------------------------------ |
| 脏读       | 一个事务读到另外一个事务还没有提交的数据。                   |
| 不可重复读 | 一个事务先后读取同一条记录，但两次读取的数据不同，称之为不可重复读。 |
| 幻读       | 一个事务按照条件查询数据时，没有对应的数据行，但是在插入数据时，又发现这行数据已经存在，好像出现了幻影”。 |

![image-20230305205505332](./assets/image-20230305205505332.png)

![image-20230305205509862](./assets/image-20230305205509862.png)

![image-20230305205514521](./assets/image-20230305205514521.png)

#### 	事务的隔离级别：

| 隔离级别                               | 脏读 | 不可重复读 | 幻读 |
| -------------------------------------- | ---- | ---------- | ---- |
| Read uncommitted（性能高，数据不安全） | √    | √          | √    |
| Read committed                         | ×    | √          | √    |
| Repeatable Read(默认)                  | ×    | ×          | √    |
| Serializable（性能差，数据安全）       | ×    | ×          | ×    |

​	查看事务隔离级别

```sql
SELECT @@TRANSACTION_ISOLATION;
```

​	设置事务隔离级别

```sql
SET [SESSION | GLOBAL] TRANSACTION ISOLATION LEVEL {READ UNCOMMITTED | READ COMMITTED | REPEATABLE READ | SERIALIZABLE}
```

$\textcolor{red}{注意：事务的隔离级别越高，数据越安全，但是性能越低。}$

## MySQL存储引擎

### 	MySQL体系结构：

![image-20230305210148905](./assets/image-20230305210148905.png)

1. **连接层**

    最上层是一些客户端和链接服务，主要完成一些类似于连接处理、授权认证、及相关的安全方案。服务器也会为安全接入的每个客户端验证它所具有的操作权限。

2. **服务层**

    第二层架构主要完成大多数的核心服务功能，如SQL接口，并完成缓存的查询，SQL的分析和优化，部分内置函数的执行。所有跨存储引擎的功能也在这一层实现，如过程、函数等。

3. **引擎层**

    存储引擎真正的负责了MySQL中数据的存储和提取，服务器通过API和存储引擎进行通信。不同的存储引擎具有不同的功能，这样我们可以根据自己的需要，来选取合适的存储引擎。

4. **存储层**

    主要是将数据存储在文件系统之上，并完成与存储引擎的交互。

### 存储引擎简介：

​	存储引擎就是存储数据、建立索引、更新/查询数据等技术的实现方式。存储引擎是基于表的，而不是基于库的，所以存储引擎也可被称为表类型。

​	在创建表的时候，指定存储引擎

```sql
CREATE TABLE 表名(
    字段 类型 COMMENT '注释',
    字段 类型 COMMENT '注释'
) ENGINE = 存储引擎 COMMENT '注释';
```

​	查看当前数据开支持的存储引擎

```sql
OW ENGINES;
```

### 存储引擎特点：

​	介绍：

​		INNODB是一中兼顾高可靠性和高性能的通用存储引擎，在MySQL5.5之后，INNODB是默认的MySQL存储引擎。

​	特点：

​		DML操作遵循ACID模型，支持$\textcolor{rgb(255, 153, 1)}{事务}$

​		$\textcolor{rgb(255, 153, 1)}{行级锁}$，提高并发访问性能

​		支持$\textcolor{rgb(255, 153, 1)}{外键}$FOREIGN KEY约束，保证数据的完整性和正确性

​	文件：

​		xxx.ibd：xxx代表的是表名，innoDB引擎的每张表都会有这样一个空间文件，存储该表的表结构（frm，sdi），数据引擎。

​		参数：innodb_file_per_table

```sql
# 查看表文件
SHOW VARIABLES LIKE 'innodb_file_per_table';

# 查看ibd文件内容
ibd2sdi xxx.ibd
```

#### InnoDB 逻辑结构图：

![image-20230309144411749](./assets/image-20230309144411749.png)

#### MyISAM：

介绍：

​	MyISAM是MySQL早期的默认引擎

特点：

​	不支持事务，不支持外键

​	支持表锁，不支持行锁

​	访问速度快

包括文件：

![image-20230309144529814](./assets/image-20230309144529814.png)

xxx.sdi表结构 	

xxx.MYD表数据	

xxx.MYI索引

#### Memory：

介绍：

​	Memoryi引擎的表数据是存储在内存中的，由于受到硬件问题、或断电问题的影响，只能将这些表作为临时表或缓存使用。

特点：

​	内存存放

​	hash索引（默认）

文件：

​	xxx.sdi：存储表结构信息

#### 存储引擎特点：

| 特点         | InnoDB            | MyISAM | Memory |
| ------------ | ----------------- | ------ | ------ |
| 存储限制     | 64TB              | 有     | 有     |
| 事务安全     | 支持              | \----  | \----  |
| 锁机制       | 行锁              | 表锁   | 表锁   |
| B+tree索引   | 支持              | 支持   | 支持   |
| Hash索引     | \----             | \----  | 支持   |
| 全文索引     | 支持(5.6版本之后) | 支持   | \----  |
| 空间使用     | 高                | 低     | N/A    |
| 内存使用     | 高                | 低     | 中等   |
| 批量插入速度 | 低                | 高     | 高     |
| 支持外键     | 支持              | \----  | \----  |

#### 存储引擎选择

在选择存储引擎时，应该根据应用系统的特点选择合适的存储引擎。对于复杂的应用系统，还可以根据实际情况选择多种存储引擎进行组合。

-   InnoDB：是Mysq的默认存储引擎，支持事务、外键。如果应用对事务的完整性有比较高的要求，在并发条件下要求数据的一致性，数据操作除了插入和查询之外，还包含很多的更新、删除操作，那么InnoDB存储引擎是比较合适的选择。
-   MyISAM：如果应用是以读操作和插入操作为主，只有很少的更新和删除操作，并且对事务的完整性、并发性要求不是很高，那么选择这个存储引擎是非常合适的。
-   MEMORY：将所有数据保存在内存中，访问速度快，通常用于临时表及缓存。MEMORY的缺陷就是对表的大小有限制，太大的表无法缓存在内存中，而且无法保障数据的安全性。

## 索引：

### 	概述：

​	索引（index)是帮助MySQL高效获取数据的数据结构（有序）。在数据之外，数据库系统还维护着满足特定查找算法的数据结构，这些数据结构以某种方式引用（指向）数据，这样就可以在这些数据结构上实现高级查找算法，这种数据结构就是索引。

![image-20230309145601912](./assets/image-20230309145601912.png)

### 优缺点：

| 优势                                                         | 劣势                                                         |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| 提高数据检索的效率，降低数据库的O成本                        | 索引列也是要占用空间的。                                     |
| 通过索引列对数据进行排序，降低数据排序的成本，降低CPU的消耗。 | 索引大大提高了查询效率，同时却也降低更新表的速度，如对表进行INSERT、UPDATE、DELETE时，效率降低。 |

### 索引结构：

MySQL的索引是在存储引擎层实现的，不同的存储引擎有不同的结构，主要包含以下几种：

| 索引结构              | 描述                                                         |
| --------------------- | ------------------------------------------------------------ |
| B+Tree索引            | 最常见的索引类型，大部分引擎都支持B+树索引                   |
| Hash索引              | 底层数据结构是用哈希表实现的，只有精确匹配索引列的查询才有效不支持范围查询 |
| R-Tree(空间索引)      | 空间索引是MyISAM引擎的一个特殊索引类型，主要用于地理空间数据类型，通常使用较少 |
| Full-text（全文索引） | 是一种通过建立倒排索引，快速匹配文档的方式。类似于Lucene,Solr,ES |

#### 索引结构：

| 索引                  | InnoDB          | MyISAM | Memory |
| --------------------- | --------------- | ------ | ------ |
| B+Tree索引            | 支持            | 支持   | 支持   |
| Hash索引              | 不支持          | 不支持 | 支持   |
| R-Tree(空间索引)      | 不支持          | 支持   | 不支持 |
| Full-text（全文索引） | 5.6版本之后支持 | 支持   | 不支持 |

$\textcolor{red}{我们平常所说的索引，如果没有特别指明，都是B+Tree结构组织的索引}$

#### 索引结构图以及演示：

二叉树：

![image-20230309150230361](./assets/image-20230309150230361.png)

$\textcolor{red}{二叉树缺点：顺序插入时，会形成一个链表，查询性能大大降低。大数据量情况下，层级较深，检索速度慢。}$

$\textcolor{red}{红黑树：大数据量情况下，层级较深，检索速度慢。}$

B-Tree（多路平衡查找树）：

​	以一颗最大度数（max-degree）为5（5阶）的B-Tree为例（每个节点最多存储4个Key，5个指针）

​	$\textcolor{red}{树的度数指的是一个节点的子节点个数}$

![image-20230309150508584](./assets/image-20230309150508584.png)

演示：

插入数据

```
插入100 65 169 368 900 556 780 35 215 1200 234 888 158 90 1000 88 120 268 250数据为例。
```

网址：https://www.cs.usfca.edu/~galles/visualization/Algorithms.html

形成裂变：中间元素向上裂变

![image-20230309150926006](./assets/image-20230309150926006.png)

B+Tree：

以一颗最大度数（max-degree）为4（4阶）的B+Tree为例

![image-20230309150940349](./assets/image-20230309150940349.png)

$\textcolor{red}{特点：}$

​	$\textcolor{red}{非叶子节点的元素起到索引的作用}$

​	$\textcolor{red}{所有的元素都会出现在叶子节点}$

​	$\textcolor{red}{叶子节点形成单项列表}$

演示：

​	添加数据

```
插入100 65 169 368 900 556 780 35 215 1200 234 888 158 90 1000 88 120 268 250数据为例。
```

![image-20230309153132403](./assets/image-20230309153132403.png)

### 索引结构：

#### 	MySQL中B+Tree

MySQL索引数据结构对经典的B+Tree进行了优化。在原B+Tree的基础上，增加了一个指向相邻叶子节点的链表指针，就形成了带有顺序指针的B+Tree，提高区间访问性能。

![image-20230310145554752](./assets/image-20230310145554752.png)

#### 	Hash：

哈希索引就是采用一定的Hash算法，将键值换算成新的Hash值，映射到对应的槽位上，然后存储在hash表中

如果两个（或多个）键值，映射到相同的槽位上，他们就产生了Hash冲突（也成为Hash碰撞），可以通过链表来解决

![image-20230313091008868](./assets/image-20230313091008868.png)

##### Hash索引特点：

1.  Hash索引只能用于对等比较（=，in），不支持范围查询（between，>，<，....）（因为Hash值存储的时候是没有顺序的）
2.  无法利用索引完成排序操作（因为Hash值存储的时候是没有顺序的）
3.  查询效率高，通常只通过一次检索就可以了，效率通常高于B+Tree索引（没有Hash值碰撞，会到链表中进行查找）

##### 存储引擎支持：

在MySQL中，支持Hash索引的是Memory引擎，而InnoDB中具有自适应hash功能（MySQL根据查询条件在指定的条件下会自动的将B+Tree索引构建成Hash索引），hash索引是存储引擎根据B+Tree索引指定条件下自动构建的。

##### 问什么innoDB存储引擎选择使用B+Tree？

-   相对于二叉树，层级更少，搜索效率高
-   相对于B-Tree，无论是叶子节点还是非叶子节点，都会保存数据，这样导致一页中存储的键值减少，指针跟着减少，要同样保存大量的数据，只能增加树的高度，导致性能降低
-   相对于Hash索引，B+Tree支持范围匹配及排序操作

### 索引的分类

| 分类     | 含义                                                 | 特点                     | 关键字   |
| -------- | ---------------------------------------------------- | ------------------------ | -------- |
| 主键索引 | 针对于表中主键创建的索引                             | 默认自动创建，只能有一个 | PRIMARY  |
| 唯一索引 | 避免同一个表中某数据列中的值重复                     | 可以有多个               | UNIQUE   |
| 常规索引 | 快速定位特定的数据                                   | 可以有多个               |          |
| 全文索引 | 全文索引查找的是文本中的关键词，而不是比较索引中的值 | 可以有多个               | FULLTEXT |

#### 在InnoDB存储引擎中，根据索引的存储形式，又可以分为以下两种：

| 分类                                                | 含义                                                       | 特点                 |
| --------------------------------------------------- | ---------------------------------------------------------- | -------------------- |
| 聚集索引（Clustered index）                         | 将数据存储与索引放到了一块，索引结构的叶子节点保存了行数据 | 必须有，而且只有一个 |
| 二级索引（Secondary index）（辅助索引，非聚集索引） | 将数据与索引分开存储，索引结构的叶子节点关联的是对应的主键 | 可以存在多个         |

#### 聚集索引的选取规则：

-   如果存在主键，主键索引就是聚集索引
-   如果不存在主键，将使用第一个唯一（UNIQUE）索引作为聚集索引
-   如果表中没有主键，或没有合适的唯一索引，则InnoDB会自动生成一个rowid作为隐藏的聚集索引

![image-20230313092925862](./assets/image-20230313092925862.png)

![image-20230313092935271](./assets/image-20230313092935271.png)

#### 以下那条SQL 执行效率高：

```

```
